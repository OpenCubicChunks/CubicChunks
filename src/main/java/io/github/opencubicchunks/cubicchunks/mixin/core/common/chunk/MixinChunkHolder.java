package io.github.opencubicchunks.cubicchunks.mixin.core.common.chunk;

import com.mojang.datafixers.util.Either;
import io.github.opencubicchunks.cubicchunks.chunk.IBigCube;
import io.github.opencubicchunks.cubicchunks.chunk.IChunkManager;
import io.github.opencubicchunks.cubicchunks.chunk.ICubeHolder;
import io.github.opencubicchunks.cubicchunks.chunk.cube.BigCube;
import io.github.opencubicchunks.cubicchunks.chunk.cube.CubePrimer;
import io.github.opencubicchunks.cubicchunks.chunk.cube.CubePrimerWrapper;
import io.github.opencubicchunks.cubicchunks.chunk.util.CubePos;
import io.github.opencubicchunks.cubicchunks.network.PacketCubeBlockChanges;
import io.github.opencubicchunks.cubicchunks.network.PacketDispatcher;
import io.github.opencubicchunks.cubicchunks.utils.AddressTools;
import it.unimi.dsi.fastutil.shorts.ShortArrayList;
import it.unimi.dsi.fastutil.shorts.ShortArraySet;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.ChunkPos;
import net.minecraft.world.World;
import net.minecraft.world.chunk.Chunk;
import net.minecraft.world.chunk.ChunkStatus;
import net.minecraft.world.chunk.IChunk;
import net.minecraft.world.lighting.WorldLightManager;
import net.minecraft.world.server.ChunkHolder;
import net.minecraft.world.server.ChunkManager;
import org.spongepowered.asm.mixin.*;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.Redirect;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicReferenceArray;
import java.util.function.BiConsumer;

import static io.github.opencubicchunks.cubicchunks.chunk.util.Utils.unsafeCast;

@Mixin(ChunkHolder.class)
public abstract class MixinChunkHolder implements ICubeHolder {

    @Shadow private int ticketLevel;
    @Mutable @Final @Shadow private ChunkPos pos;

    // these are using java type erasure as a feature - because the generic type information
    // doesn't exist at runtime, we can shadow those fields with different generic types
    // and as long as we are consistent, we can use them with different types than the declaration in the original class
    @Shadow @Final private AtomicReferenceArray<CompletableFuture<Either<IBigCube, ChunkHolder.IChunkLoadingError>>> futures;
    @Shadow private volatile CompletableFuture<Either<BigCube, ChunkHolder.IChunkLoadingError>> tickingChunkFuture;
    @Shadow private volatile CompletableFuture<Either<BigCube, ChunkHolder.IChunkLoadingError>> entityTickingChunkFuture;
    @Shadow private CompletableFuture<IBigCube> chunkToSave;


    @Shadow private int skyChangedLightSectionFilter;
    @Shadow private int blockChangedLightSectionFilter;
    @Shadow private int queueLevel;

    @Shadow protected abstract void broadcastBlockEntity(World worldIn, BlockPos posIn);

    @Shadow @Final private ChunkHolder.IPlayerProvider playerProvider;

    @Shadow protected abstract void updateChunkToSave(
            CompletableFuture<? extends Either<? extends IChunk, ChunkHolder.IChunkLoadingError>> eitherChunk);

    @Shadow public static ChunkStatus getStatus(int level) {
        throw new Error("Mixin failed to apply");
    }

    @Shadow public abstract CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> getFutureIfPresentUnchecked(ChunkStatus p_219301_1_);

    @Shadow
    public abstract CompletableFuture<Either<IBigCube, ChunkHolder.IChunkLoadingError>> getOrScheduleFuture(ChunkStatus chunkStatus,
                                                                                                          ChunkManager chunkManager);

    private CubePos cubePos; // set from ASM

    private final ShortArraySet changedLocalBlocks = new ShortArraySet();

    //BEGIN INJECTS:

    // target generated by ASM
    @SuppressWarnings("target")
    @Dynamic("Generated by ASM by copying and transforming original constructor")
    @Inject(method = "<init>(Lio/github/opencubicchunks/cubicchunks/chunk/util/CubePos;ILnet/minecraft/world/lighting/WorldLightManager;"
            + "Lnet/minecraft/world/server/ChunkHolder$IListener;Lnet/minecraft/world/server/ChunkHolder$IPlayerProvider;)V",
            at = @At("RETURN")
    )
    public void onConstructCubeHolder(CubePos cubePosIn, int levelIn, WorldLightManager lightManagerIn, ChunkHolder.IListener p_i50716_4_,
            ChunkHolder.IPlayerProvider playerProviderIn, CallbackInfo ci) {
        this.pos = cubePosIn.asChunkPos();
    }

    // used from ASM
    private static ChunkStatus getCubeStatus(int cubeLevel) {
        return ICubeHolder.getCubeStatusFromLevel(cubeLevel);
    }

    @Inject(method = "updateFutures", at = @At("HEAD"), cancellable = true)
    void updateFutures(ChunkManager chunkManagerIn, CallbackInfo ci) {
        /*
         If sectionPos == null, this is a ChunkManager
         else, this is a CubeManager.
         This is being implemented as a mixin, instead of having a specific CubeManager class.
         this.sectionPos is essentially being used as a flag for changing behaviour.
         */
        if(this.cubePos == null) {
            return;
        }
        ci.cancel();
        updateCubeFutures(chunkManagerIn);
    }

    @Override
    public CubePos getCubePos() {
        return cubePos;
    }

    // getChunkIfComplete
    @Nullable
    @Override
    public BigCube getCubeIfComplete() {
        CompletableFuture<Either<BigCube, ChunkHolder.IChunkLoadingError>> completablefuture = this.tickingChunkFuture;
        Either<BigCube, ChunkHolder.IChunkLoadingError> either = completablefuture.getNow(null);
        return either == null ? null : either.left().orElse(null);
    }

    @Override
    public CompletableFuture<Either<BigCube, ChunkHolder.IChunkLoadingError>> getCubeEntityTickingFuture() {
        return this.entityTickingChunkFuture;
    }

    // func_219301_a, getFutureIfPresentUnchecked
    @Override
    public CompletableFuture<Either<IBigCube, ChunkHolder.IChunkLoadingError>> getCubeFutureIfPresentUnchecked(ChunkStatus chunkStatus) {
        return unsafeCast(getFutureIfPresentUnchecked(chunkStatus));
    }

    // func_219302_f, getChunkToSave
    @Override
    public CompletableFuture<IBigCube> getCubeToSave() {
        return chunkToSave;
    }

    // func_225410_b, getFutureIfPresent
    @Override public CompletableFuture<Either<IBigCube, ChunkHolder.IChunkLoadingError>> getCubeFutureIfPresent(ChunkStatus chunkStatus) {
        return ICubeHolder.getCubeStatusFromLevel(this.ticketLevel).isOrAfter(chunkStatus) ?
                unsafeCast(this.getFutureIfPresentUnchecked(chunkStatus)) : // getFutureIfPresentUnchecked = getFutureByCubeStatus
                MISSING_CUBE_FUTURE;
    }


    private AtomicReferenceArray<ArrayList<BiConsumer<Either<IBigCube, ChunkHolder.IChunkLoadingError>, Throwable>>> listenerLists = new AtomicReferenceArray<>(ChunkStatus.getStatusList().size());


    // func_219276_a, getOrScheduleFuture
    @Redirect(method = "getOrScheduleFuture", at = @At(
            value = "INVOKE",
            target = "Lnet/minecraft/world/server/ChunkHolder;getStatus(I)Lnet/minecraft/world/chunk/ChunkStatus;"
    ))
    private ChunkStatus getChunkOrCubeStatus(int level) {
        if (cubePos == null) {
            return getStatus(level);
        } else {
            return getCubeStatus(level);
        }
    }

    @Redirect(method = "getOrScheduleFuture", at = @At(
            value = "INVOKE",
            target = "Lnet/minecraft/world/server/ChunkManager;schedule(Lnet/minecraft/world/server/ChunkHolder;Lnet/minecraft/world/chunk/ChunkStatus;)Ljava/util/concurrent/CompletableFuture;"
    ))
    private CompletableFuture<?> scheduleChunkOrCube(ChunkManager chunkManager, ChunkHolder _this, ChunkStatus status) {
        if (cubePos == null) {
            return chunkManager.schedule(_this, status);
        } else {
            return ((IChunkManager) chunkManager).scheduleCube(_this, status);
        }
    }

    // func_219276_a, getOrScheduleFuture
    @Override public CompletableFuture<Either<IBigCube, ChunkHolder.IChunkLoadingError>> getOrScheduleCubeFuture(ChunkStatus chunkStatus, ChunkManager chunkManager) {
        return getOrScheduleFuture(chunkStatus, chunkManager);
    }

    public void addCubeStageListener(ChunkStatus status, BiConsumer<Either<IBigCube, ChunkHolder.IChunkLoadingError>, Throwable> consumer, ChunkManager chunkManager) {
        CompletableFuture<Either<IBigCube, ChunkHolder.IChunkLoadingError>> future = getOrScheduleFuture(status, chunkManager);

        if (future.isDone()) {
            consumer.accept(future.getNow(null), null);
        } else {
            List<BiConsumer<Either<IBigCube, ChunkHolder.IChunkLoadingError>, Throwable>> listenerList = this.listenerLists.get(status.getIndex());
            if (listenerList == null) {

                final ArrayList<BiConsumer<Either<IBigCube, ChunkHolder.IChunkLoadingError>, Throwable>> listeners = new ArrayList<>();
                future.whenComplete((either, throwable) -> {
                    for (BiConsumer<Either<IBigCube, ChunkHolder.IChunkLoadingError>, Throwable> listener : listeners) {
                        listener.accept(either, throwable);
                    }
                    listeners.clear();
                    listeners.trimToSize();
                });
                this.listenerLists.set(status.getIndex(), listeners);
                listenerList = listeners;
            }

            listenerList.add(consumer);
        }
    }


    // TODO: this needs to be completely replaced for proper section handling
    /**
     * @author Barteks2x**
     * @reason height limits
     */
    @Overwrite
    public void blockChanged(BlockPos blockPos) {
        if (cubePos == null) {
            throw new IllegalStateException("Why is this getting called?");
        }
        BigCube cube = getCubeIfComplete();
        if (cube == null) {
            return;
        }
        changedLocalBlocks.add((short) AddressTools.getLocalAddress(blockPos.getX(), blockPos.getY(), blockPos.getZ()));
    }

    /**
     * @author Barteks2x
     * @reason replace packet classes with CC packets
     */
    @Overwrite
    public void broadcastChanges(Chunk chunkIn) {
        if (cubePos != null) {
            throw new IllegalStateException("Why is this getting called?");
        }
        // noop
    }

    @Override
    public void broadcastChanges(BigCube cube) {
        if (cubePos == null) {
            throw new IllegalStateException("broadcastChanges(BigCube) called on column holder!");
        }
        if (this.changedLocalBlocks.isEmpty() && this.skyChangedLightSectionFilter == 0 && this.blockChangedLightSectionFilter == 0) {
            return;
        }
        World world = cube.getWorld();
        // if (this.skyLightChangeMask != 0 || this.blockLightChangeMask != 0) {
        //     this.sendToTracking(new SUpdateLightPacket(section.getPos(), this.lightManager, this.skyLightChangeMask & ~this.boundaryMask,
        //             this.blockLightChangeMask & ~this.boundaryMask), true);
        //     int i = this.skyLightChangeMask & this.boundaryMask;
        //     int j = this.blockLightChangeMask & this.boundaryMask;
        //     if (i != 0 || j != 0) {
        //         this.sendToTracking(new SUpdateLightPacket(section.getPos(), this.lightManager, i, j), false);
        //     }
        //     this.skyLightChangeMask = 0;
        //     this.blockLightChangeMask = 0;
        //     this.boundaryMask &= ~(this.skyLightChangeMask & this.blockLightChangeMask);
        // }

        ShortArraySet changed = changedLocalBlocks;
        int changedBlocks = changed.size();
//        if (changed.size() >= net.minecraftforge.common.ForgeConfig.SERVER.clumpingThreshold.get()) {
//            this.queueLevel = -1;// boundaryMask
//        }
//
//        if (changedBlocks >= net.minecraftforge.common.ForgeConfig.SERVER.clumpingThreshold.get()) {
//            this.sendToTracking(new PacketCubes(Collections.singletonList(cube)), false);
//        }

        if (changedBlocks != 0) {
            this.sendToTracking(new PacketCubeBlockChanges(cube, new ShortArrayList(changed)), false);
            for (short pos : changed) {
                BlockPos blockpos1 = new BlockPos(
                        this.cubePos.blockX(AddressTools.getLocalX(pos)),
                        this.cubePos.blockY(AddressTools.getLocalY(pos)),
                        this.cubePos.blockZ(AddressTools.getLocalZ(pos)));
                if (world.getBlockState(blockpos1).hasTileEntity()) {
                    this.broadcastBlockEntity(world, blockpos1);
                }
            }
        }
        changedLocalBlocks.clear();
    }

    private void sendToTracking(Object packetIn, boolean boundaryOnly) {
        // TODO: fix block update tracking
        this.playerProvider.getPlayers(this.cubePos.asChunkPos(), boundaryOnly)
                .forEach(player -> PacketDispatcher.sendTo(packetIn, player));
    }

    // func_219294_a, replaceProtoChunk
    @Override
    public void replaceProtoCube(CubePrimerWrapper primer) {
        for(int i = 0; i < this.futures.length(); ++i) {
            CompletableFuture<Either<IBigCube, ChunkHolder.IChunkLoadingError>> future = this.futures.get(i);
            if (future != null) {
                Optional<IBigCube> optional = future.getNow(MISSING_CUBE).left();
                if (optional.isPresent() && optional.get() instanceof CubePrimer) {
                    this.futures.set(i, CompletableFuture.completedFuture(Either.left(primer)));
                }
            }
        }

        this.updateChunkToSave(unsafeCast(CompletableFuture.completedFuture(Either.left((IBigCube) primer.getCube()))));
    }
}